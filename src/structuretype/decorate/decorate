“单一职责模式”：
    在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，
    同时充斥着重复的代码，这时候的关键往往是划清责任

    典型模式：
        Decorator
        Bridge


Decorator模式：
    动机：在某些情况下我们可能会”过渡的使用继承来扩展对象的功能“，由于继承为类型引入的静态特质，
          使得这种扩展方式缺乏灵活性；并且随着子类的增加（扩展功能的增多），各种子类的组合（扩展功能的组合）
          会导致子类的膨胀。

          如何使”对象功能的扩展“能够根据需求来动态的实现呢？同时避免”扩展功能的增多“带来的子类膨胀问题？
          从而使得任何“功能扩展变化”所导致的影响降为最低？

    模式定义（GOF:）：
        动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）
        更为灵活（消除重复代码 & 减少子类个数）

    要点总结：
        通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要
        扩展多个功能，避免了使用继承带来的“灵活性差”和“多子类衍生问题”

        Decorator类在接口上表现为“is-a”Component的继承关系，即Decorator类继承了Component类所具有的接口。
        但在实现上又表现为“has-a”Component的组合关系，即Decortor类又使用了另外一个Component类

        Decortor模式的目的并非解决“多子类衍生的多继承”问题，它应用的要点在于解决“主体类在多个方向上的扩展功能”
        是为“装饰”的含义